/* Instructions: In this variation session, we will solve the same problem 3 different ways. The basic problem is:
 * Given an array of positive integers, find the first element that occurs k number of times. If no element occurs k times, return -1. You may assume k 
 * is greater than 0.
 * Examples:
 * • Given an array: [1, 2, 2, 3, 3], k: 2 // returns 2
 * • Given an array: [], k: 1 // returns -1
 * The standard solution is to use a dictionary to keep track of the number of repetitions. Early return when you find an element that hits k repeats.
 * The original solution, but do not return early. Build up the full dictionary of counts. Iterate through the array again and return the first one whose 
 * count is greater than or equal to k. Discuss how this does not change the overall runtime or space complexity.
 * For each element, iterate through the rest of the array to see if it's repeated k times. If it is, return it. Otherwise, go on to the next element. 
 * Walk through how this approach is O(n^2) runtime.
*/
